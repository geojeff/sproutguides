h2. Getting Started: Part 2


In Part 1, we walked through the basic elements of a SproutCore app. In Part 2
we introduce some of the guiding concepts behind a SproutCore application
such as views, controllers, and statecharts.

In Part 2, you will:

* Learn about statecharts and how they can improve your application.
* Create a new statechart-based SproutCore application.
* Learn about views and how they should handle events.
* Learn how to separate views in individual files with the use of _sc_require()_.
* Learn how to pass events to the application's statechart.

endprologue.

h3. Why Statecharts?

If you've ever built any sizable application, or even small ones for that matter, you've
probably run into a bug that was caused by some piece of logic that didn't work quite as
you intended.

Perhaps it was an if statement with an invalid test expression, or some piece of code that changed
a variable that you weren't expecting to be updated. Some bugs happen because you don't understand
how your app would react under a particular set of conditions.

Statecharts help reduce uncertainty, by defining more explicitly what can, and cannot, happen
within your application. You think of discrete states, such as "showing login panel." You think
of transitions between states -- for example, what should happen as the login panel is shown, what 
could happen while it is showing, and what should happen when it is taken down.

h3. What is a Statechart?

A statechart is a simple, nested construct that helps you better organize your code into
logical, and hierarchical states. Your applications will have many states,
and each state may have many substates within it. Each state can respond to a certain
set of actions, the name for events associated with a statechart.

NOTE: Semantics: action === "event," for a statechart. event, technically === mouseDown, etc. It can
help to make that specific distinction for a SproutCore app. In discussions, clarify when needed.

Consider a statechart application with the following top-level states, substates, and actions:

# LOADING
#* _loadingFinished_
# LOADED
##* _viewTermsOfService_
##* _viewPrivacyPolicy_
### LOGGED_OUT
###* _login_
### LOGGED_IN
###* _createTodo_
###* _completeTodo_
###* _clearTodos_

In the list above, the states are in ALL-CAPS, the actions are in italics.

INFO: Through most of the Getting Started guides, you will see states in ALL_CAPS for the sake of continuity.
However, states are standard SC objects and can follow any naming convention you want.  Many developers
prefer CamelCase (i.e., MyApp.LoggedInState) while others prefer namespacing their states (i.e.,
MyApp.States.LoggedIn).  Some prefer to use verb-style, vs. noun-style state names. Whatever method you 
choose is fine, just be consistent, so you, and other developers, can more easily follow your code.

NOTE: A state is a state is a state. A substate is a state. (You can always use the term state; when you
use the term substate, the reference is relative to a parent state).

h4. Decoding the Statechart

In our example here, the application can be in one of the two top level states: LOADING or LOADED. If it is in 
one, it cannot be in the other. When it is in the LOADING state, the only available action is the 
_loadingFinished_ action. The statechart/application should not respond to any other events. Once it moves into
the LOADED state, it can be in two additional states, substates of the LOADED state: LOGGED_OUT or LOGGED_IN. 
Again, it can only be in one at a given time, so when the user is "logged out", after the application has 
loaded, the only available action is the _login_ action.

However, notice that the _viewTermsOfService_ action and the _viewPrivacyPolicy_ action are both available in
the LOADED state. This means that regardless of whether the user is in the LOGGED_OUT state or the LOGGED_IN
state, they should be allowed to view the terms of service or the privacy policy.

Once the user has authenticated and logged in, they have three actions available: the _createTodo_,
_completeTodo_ and _clearTodos_ actions.

h4. How Statecharts Help

As you can see, your application only responds to certain actions at certain times. This makes it
much easier to verify that your app is working properly, by ensuring that events are handled exactly when they
need to be handled, and that even if, because of a bug in the design, your user interface allows an action when 
it shouldn't (like creating a todo when you are logged out), the application itself will maintain a consistent 
state and continue to operate.

Additionally, all states may define an _enterState()_ and an _exitState()_ function to help them prepare for
the new state, and to clean up after themselves. Generally, these functions are where you show or hide user
interface components, or set the content of controllers.

h3. Creating the Statechart

So let's go ahead and create a statechart-based SproutCore app!

<shell>
$ cd ~/development/sproutcore/getting_started
$ sproutcore gen statechart_app TodosTwo
   ~ Created directory at apps/todos_two
   ~ Created file at apps/todos_two/Buildfile
   ~ Created file at apps/todos_two/core.js
   ~ Created file at apps/todos_two/main.js
   ~ Created directory at apps/todos_two/resources
   ~ Created file at apps/todos_two/resources/_theme.css
   ~ Created file at apps/todos_two/resources/loading.rhtml
   ~ Created file at apps/todos_two/resources/main_page.js
   ~ Created file at apps/todos_two/statechart.js
   ~ Created directory at apps/todos_two/states
   ~ Created file at apps/todos_two/states/ready_state.js
   ~ Created file at apps/todos_two/theme.js

  Your application target is now ready to use!
</shell>

The directory structure is:

* *getting_started/*
** *Buildfile*
** *README.md*
** *apps/*
*** *todos_one/*
**** *...*
*** *todos_two/*
**** *Buildfile*
**** *core.js*
**** *main.js*
**** *_statechart.js_*
**** *theme.js*
**** *resources/*
***** *_theme.css*
***** *loading.rhtml*
***** *main_page.js*
**** *_states/_*
***** *_ready_state.js_*

This structure looks almost identical to the standard app, except that you now see two new files,
a _statechart.js_ file in the application root directory, and a new _states_ directory with one state file,
_ready_state.js_:

* _statechart.js_, and
* _states/ready_state.js_

The _statechart.js_ file describes your statechart and the initial state that should be entered when the
statechart is first initialized. Open it, and you should see the following:

<javascript filename="apps/todos_two/statechart.js">
TodosTwo.statechart = SC.Statechart.create({

  initialState: 'readyState',

  readyState: SC.State.plugin('TodosTwo.ReadyState'),
  // someOtherState: SC.State.plugin('TodosTwo.SomeOtherState')

});
</javascript>

NOTE: This example uses CamelCase state names.

Note the use of SC.Statechart.create(), instead of SC.Statechart.extend().  Views and models generally 
use .extend() when you are defining them, because elsewhere in the system, instantiation of objects happens.
Controllers and the statechart use .create() because we need to directly create objects to work with. 

Also note the use of the SC.State.plugin() function. This allows you to put your states in separate files in a
states directory.

Open _states/ready_state.js_ and take a look:

<javascript filename="apps/todos_two/states/ready_state.js">
TodosTwo.ReadyState = SC.State.extend({ 

  enterState: function() {
    TodosTwo.getPath('mainPage.mainPane').append();
  },
 
  exitState: function() {
    TodosTwo.getPath('mainPage.mainPane').remove();
  }

});
</javascript>

The TodosTwo.ReadyState is the only state entered, so it just appends the main
page's main pane. We'll talk about panes and views in just a minute. The key
here is to see that the _exitState()_ function does the opposite of the what the
_enterState()_ function does.

h3. Where Views Fit In

We've talked about statecharts, so you know a little bit about how they
work. Let's talk about how statecharts can clean up your views and make
your code super-clean.

The _resources/main_page.js_ file defines the main user interface of your application.
As you build your app, you will modify this file to add different views. 

Edit the file to add a second child view, labelView2:

<javascript filename="apps/todos_two/resources/main_page.js">
TodosTwo.mainPage = SC.Page.design({
  
  mainPane: SC.MainPane.design({
    childViews: 'labelView labelView2'.w(),
    
    labelView: SC.LabelView.design({
      layout: { centerX: 0, centerY: 0, width: 200, height: 18 },
      textAlign: SC.ALIGN_CENTER,
      tagName: "h1", 
      value: "Welcome to SproutCore!"
    }),
    
    labelView2: SC.LabelView.design({
      layout: { centerX: 0, centerY: 15, width: 200, height: 18 },
      textAlign: SC.ALIGN_CENTER,
      tagName: "h1", 
      value: "Now we're rolling!"
    })
  })

});
</javascript>

INFO: Throughout the guides we have omitted the code comments for brevity.

NOTE: You may have observed the use of the _.design()_ method instead of
_.extend()_. Views generally use _.design()_ in order to work with the graphical
designer that is being developed for SproutCore. TODO: Is this actually correct?

If you load up "http://localhost:4020/todos_two/":http://localhost:4020/todos_two/
in your browser, you should see both labels now; the second one right below the first.

h4. Separating Views

Before we get into using views with statecharts, let's first talk about
how to arrange your view files. Technically, you can shove all of it into
<em>main_page.js</em>, but that will get impractical very fast. Instead you should
separate each view into it's own file. This is easily accomplished by
using the special _sc_require()_ function, so let's do this now.

Create a new folder in your _apps/todos_two_ folder called 'views':

<shell>
$ cd ~/development/sproutcore/getting_started
$ mkdir apps/todos_two/views
</shell>

Next, let's separate each view into it's own file inside the views directory.
Make sure the files have the following content and are located in the views
directory:

<javascript filename="apps/todos_two/resources/main_page.js">
sc_require('views/welcome');
sc_require('views/rolling');

TodosTwo.mainPage = SC.Page.design({

  mainPane: SC.MainPane.design({
    childViews: 'welcomeView rollingView'.w(),
    
    welcomeView: TodosTwo.WelcomeView.design(),
    rollingView: TodosTwo.RollingView.design()
  })

});
</javascript>

<javascript filename="apps/todos_two/views/welcome.js">
TodosTwo.WelcomeView = SC.LabelView.design({
  layout: { centerX: 0, centerY: 0, width: 200, height: 18 },
  textAlign: SC.ALIGN_CENTER,
  tagName: "h1", 
  value: "Welcome to SproutCore!"
});
</javascript>

<javascript filename="apps/todos_two/views/rolling.js">
TodosTwo.RollingView = SC.LabelView.design({
  layout: { centerX: 0, centerY: 15, width: 200, height: 18 },
  textAlign: SC.ALIGN_CENTER,
  tagName: "h1", 
  value: "Now we're rolling!"
});
</javascript>

Above, you'll notice a few things:

# Since we reference TodosTwo.WelcomeView and TodosTwo.RollingView in the
<em>main_page.js</em> file, we must use _sc_require()_ at the top to tell
SproutCore that it should load those files first. This ensures that all
of the files are included in the proper order.
# The file path used in _sc_require()_ is relative to the application's
directory, not where the file is located.
# The reference in _sc_require()_ has the filename sans the .js extension.

If you refresh your page, everything should look exactly as it did before,
but now your code is cleaner and more manageable.

h4. Handling Events

Let's turn our attention to events! Here we add an event to watch for mouseDown 
in our TodosTwo.RollingView:

<javascript filename="apps/todos_two/views/rolling.js">
TodosTwo.RollingView = SC.LabelView.design({
  layout: { centerX: 0, centerY: 15, width: 200, height: 18 },
  textAlign: SC.ALIGN_CENTER,
  tagName: "h1", 
  value: "Now we're rolling!",
  
  mouseDown: function(evt) {
    var someParam = "Woot!";

    TodosTwo.statechart.sendAction('proveIt', someParam);
  }
});
</javascript>

We associated a _proveIt_ action with the mouseDown event, and must handle this action 
in the appropriate state.

The statechart has a property for the _current_ state. When the statechart recieves an 
action, it will first ask the current state to handle it. If the current state cannot 
handle it, the statechart will ask the current state's parent state to handle the event.
Attempts continue in this manner until either an ancestor state is found that can handle 
the event, or it will log a warning for the developer.  You can see this warning, as well 
as other informational messages (such as for state transitions), by turning on tracing on 
the statechart.

Do that now:

<javascript filename="apps/todos_two/statechart.js">
TodosTwo.statechart = SC.Statechart.create({
    
  trace: YES,   // <-- Add this line
    
  initialState: 'readyState',
    
  readyState: SC.State.plugin('TodosTwo.ReadyState')
  
});
</javascript>

Let's make our TodosTwo.ReadyState handle the _proveIt_ action that was defined on
the mouseDown event in TodosTwo.RollingView above:

<javascript filename="appps/todos_two/states/ready_state.js">
TodosTwo.ReadyState = SC.State.extend({
  
  enterState: function() {
    TodosTwo.getPath('mainPage.mainPane').append();
  },
    
  exitState: function() {
    TodosTwo.getPath('mainPage.mainPane').remove();
  },
  
  // Prove that we are rolling!
  proveIt: function(someParam) {
    alert(someParam);
  }

});
</javascript>

Save your files and refresh the page. When you click on the "Now we're rolling!"
label, you should see an alert. If you look at the console output, you can also
see the tracing reports, with the event being handled by the statechart, as well 
as the initialization and the transition to the readyState.

h3. Moving Forward

You are now ready to move on to creating a full-scale SproutCore app!

"Part 3":/getting_started_3.html will introduce you to the full Todos application,
called TodosThree, and walk you through the process of building it from scratch. 
You will learn about models, controllers and how they tie in with the statechart 
and views.

So go grab a hot cup of joe, or something else to steel your resolve (Joking. You
think?), and dive in to "Getting Started: Part 3":/getting_started_3.html.

h3. Changelog

* May 5, 2011: initial version by "Piotr Sarnacki":credits.html#drogus
* May 9, 2011: Stylistic edits by "Tom Dale":credits.html#tomdale
* February 29, 2012: rewrite for SproutCore 1.8 by the 1.8 release sprint team, including the following who did much work on this task: "Tim Evans":credits.html#tce, "Topher Fangio":credits.html#topherfangio, "Jeff Pittman":credits.html#geojeff

