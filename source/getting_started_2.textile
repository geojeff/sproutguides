h2. Getting Started: Part 2


In Part 1, we walked through the basic pieces of a SproutCore app. In Part 2
we introduce some of the guiding concepts behind a SproutCore application
such as views, controllers, and statecharts.

In Part 2, you'll:

* Learn about statecharts and how they can improve your application.
* Create a new statechart-based SproutCore application.
* Learn about views and how they should handle events.
* Learn how to separate your views with the use of _sc_require()_.
* Learn how to pass those events to the application's statechart.

endprologue.

h3. Why Statecharts?

If you've ever built any sizable application, or even small ones for that matter, you've
probably run into a bug that was caused by some piece of logic that didn't work quite as
you intended.

Perhaps it was an if statement with an invalid test, or some piece of code that changed
a variable that you weren't expecting to be updated.

Whatever the sitatution, it was probably caused because you didn't know exactly how your
app would react under a particular set of conditions. Statecharts aim to solve these issues by
helping you remove the uncertainty, and by defining exactly what can, and cannot, happen
within your application.

h3. What is a Statechart?

A statechart is a simple, nested construct that helps you better organize your code into
logical, and hierarchical segments called states. Your applications will have many states,
and each state may have many substates underneath it. Each state can respond to a certain
set of actions.

For instance, your application may have the following two top-level states with the
following substates and actions:

# LOADING
#* _loadingFinishedAction_
# LOADED
##* _viewTermsOfServiceAction_
##* _viewPrivacyPolicyAction_
### LOGGED_OUT
###* _loginAction_
### LOGGED_IN
###* _createTodoAction_
###* _completeTodoAction_
###* _clearTodosAction_

NOTE: Throughout the Getting Started guides, you will see states in ALL_CAPS for the sake of continuity.
However, the states are standard SC objects and can follow any naming convention you want.  Many developers
prefer CamelCase (i.e.  MyApp.LoggedInState) while others prefer namespacing their states (i.e.
MyApp.States.LoggedIn).  Whatever method you choose is fine, just be sure to be consistent so other developers
can more easily follow your code.

h4. Decoding the Statechart

Your application can either be in one of the two top level states: LOADING or LOADED. If it is in one, it
cannot be in the other. When it's in the LOADING state, the only available action is the
_loadingFinishedAction_ . The statechart/application should not respond to any other events. Once it moves into
the LOADED state, it can be in two additional substates: LOGGED_OUT or LOGGED_IN. Again, it can only be in
one, so when the user is "logged out", the only available action is _loginAction_.

However, notice that the _viewTermsOfServiceAction_ and the _viewPrivacyPolicyAction_ are both available to
the LOADED state. This means that regardless of whether the user is in the LOGGED_OUT state or the LOGGED_IN
state, they should be allowed to view the terms of service, or the privacy policy.

Once the user has authenticated and logged in, they have three new actions available: the _createTodoAction_,
the _completeTodoAction_ and the _clearTodosAction_.

h4. How Statecharts Help

As you can see, your application only responds to certain actions (or events) at certain times. This makes it
much easier to verify that your app is working properly, by ensuring that you handle events exactly when they
need to be handled, and that even if your user interface allows an action when it shouldn't (like creating a
todo when you are logged out), the application itself will maintain a consistent state and continue to
operate.

Additionally, all states may define an _enterState()_ and an _exitState()_ function to help them prepare for
the new state, or cleanup after themselves. These functions are generally where you show or hide user
interface components, or set the content on your controllers.

h3. Creating the Statechart

So let's go ahead and create a statechart-based SproutCore app!

<shell>
$ cd ~/development/sproutcore/getting_started
$ sc-gen statechart_app TodosTwo
   ~ Created directory at apps/todos_two
   ~ Created file at apps/todos_two/Buildfile
   ~ Created file at apps/todos_two/core.js
   ~ Created file at apps/todos_two/main.js
   ~ Created directory at apps/todos_two/resources
   ~ Created file at apps/todos_two/resources/_theme.css
   ~ Created file at apps/todos_two/resources/loading.rhtml
   ~ Created file at apps/todos_two/resources/main_page.js
   ~ Created file at apps/todos_two/statechart.js
   ~ Created directory at apps/todos_two/states
   ~ Created file at apps/todos_two/states/ready_state.js
   ~ Created file at apps/todos_two/theme.js

  Your application target is now ready to use!
</shell>

Your directory structure should now be similar to the following:

* *getting_started/*
** *Buildfile*
** *README.md*
** *apps/*
*** *todos_one/*
**** *...*
*** *todos_two/*
**** *Buildfile*
**** *core.js*
**** *main.js*
**** *_statechart.js_*
**** *theme.js*
**** *resources/*
***** *_theme.css*
***** *loading.rhtml*
***** *main_page.js*
**** *_states/_*
***** *_ready_state.js_*

This structure looks almost identical to the standard app, except that you should now see two new files:

* _statechart.js_, and
* _states/ready_state.js_

The _statechart.js_ file describes your statechart and the initial state that should be entered when the
statechart is first initialized. Go ahead and open it. You should see the following:

<javascript filename="apps/todos_two/statechart.js">
TodosTwo.statechart = SC.Statechart.create({

  initialState: 'readyState',

  readyState: SC.State.plugin('TodosTwo.ReadyState'),
  // someOtherState: SC.State.plugin('TodosTwo.SomeOtherState')

});
</javascript>

Notice the use of SC.Statechart.create() instead of SC.Statechart.extend().
Views and models generally use .extend() when you are defining them.
Controllers and the statechart use .create() because we want an actual object
to work with. Also note the use of the SC.State.plugin() function. This allows
you to put your states in a separate file and pull them in later.

Speaking of states, go ahead and open _states/ready_state.js_ and take a look.

<javascript filename="apps/todos_two/states/ready_state.js">
TodosTwo.ReadyState = SC.State.extend({ 

  enterState: function() {
    TodosTwo.getPath('mainPage.mainPane').append();
  },
 
  exitState: function() {
    TodosTwo.getPath('mainPage.mainPane').remove();
  }

});
</javascript>

The TodosTwo.ReadyState is the only state entered, so it just appends the main
page's main pane. We'll talk about panes and views in just minute, but the key
here to see is that the _exitState()_ function does the opposite of the
_enterState()_ function.

h3. Where Views Fit In

So, we've talked about statecharts and you know a little bit about how they
work. Now, let's talk about how statecharts can clean up your views and make
your code super-clean.

The _resources/main_page.js_ file defines the user interface of your application.
As you build your app, you will modify this file to add your different views. Go
ahead and edit the file to add a second child view like below:

<javascript filename="apps/todos_two/resources/main_page.js">
TodosTwo.mainPage = SC.Page.design({
  
  mainPane: SC.MainPane.design({
    childViews: 'labelView labelView2'.w(),
    
    labelView: SC.LabelView.design({
      layout: { centerX: 0, centerY: 0, width: 200, height: 18 },
      textAlign: SC.ALIGN_CENTER,
      tagName: "h1", 
      value: "Welcome to SproutCore!"
    }),
    
    labelView2: SC.LabelView.design({
      layout: { centerX: 0, centerY: 15, width: 200, height: 18 },
      textAlign: SC.ALIGN_CENTER,
      tagName: "h1", 
      value: "Now we're rolling!"
    })
  })

});
</javascript>

INFO: Throughout the guides we have omitted the code comments for brevity.

NOTE: Astute readers may have notied the use of the _.design()_ method instead of
_.extend()_. Views generally use _.design()_ in order to work with the graphical
designer that is being developed for SproutCore. TODO: Is this actually correct?

If you load up "http://localhost:4020/todos_two/":http://localhost:4020/todos_two/
in your browser, you should see both labels now; the second one right below the first.

h4. Separating Views

Before we get into using views with statecharts, let's first talk about
how to arrange your view files. Technically, you can shove all of it into
<em>main_page.js</em>, but that will get impractical very fast. Instead you should
separate each view into it's own file. This is easily accomplished by
using the special _sc_require()_ function, so let's do this now.

Create a new folder in your _apps/todos_two_ folder called 'views':

<shell>
$ cd ~/development/sproutcore/getting_started
$ mkdir apps/todos_two/views
</shell>

Next, let's separate each view into it's own file inside the views directory.
Make sure your files have the following content and are located in the proper
directory:

<javascript filename="apps/todos_two/resources/main_page.js">
sc_require('views/welcome');
sc_require('views/rolling');

TodosTwo.mainPage = SC.Page.design({

  mainPane: SC.MainPane.design({
    childViews: 'welcomeView rollingView'.w(),
    
    welcomeView: TodosTwo.WelcomeView.design(),
    rollingView: TodosTwo.RollingView.design()
  })

});
</javascript>

<javascript filename="apps/todos_two/views/welcome.js">
TodosTwo.WelcomeView = SC.LabelView.design({
  layout: { centerX: 0, centerY: 0, width: 200, height: 18 },
  textAlign: SC.ALIGN_CENTER,
  tagName: "h1", 
  value: "Welcome to SproutCore!"
});
</javascript>

<javascript filename="apps/todos_two/views/rolling.js">
TodosTwo.RollingView = SC.LabelView.design({
  layout: { centerX: 0, centerY: 15, width: 200, height: 18 },
  textAlign: SC.ALIGN_CENTER,
  tagName: "h1", 
  value: "Now we're rolling!"
});
</javascript>

Above, you'll notice a few things:

# Since we reference TodosTwo.WelcomeView and TodosTwo.RollingView in the
<em>main_page.js</em> file, we must use _sc_require()_ at the top to tell
SproutCore that it should load those files first. This ensures that all
of the files are included in the proper order.
# The file path used in _sc_require()_ is relative to the application's
directory, not where the file is located.

If you refresh your page, everything should look exactly as it did before,
except that your code is cleaner and more manageable.

h4. Handling Events

So, now that we have our files nicely separated, let's talk about handling
events! Let's watch for the mouseDown event in our TodosTwo.RollingView:

<javascript filename="apps/todos_two/views/rolling.js">
TodosTwo.RollingView = SC.LabelView.design({
  layout: { centerX: 0, centerY: 15, width: 200, height: 18 },
  textAlign: SC.ALIGN_CENTER,
  tagName: "h1", 
  value: "Now we're rolling!",
  
  mouseDown: function(evt) {
    var someParam = "Woot!";

    TodosTwo.statechart.sendAction('doSomeFunAction', someParam);
  }
});
</javascript>

Next, we need to handle the action in the appropriate state.

When the statechart is attempting to handle an action, it will first ask the
current state to handle the action. If the state cannot handle it, the
statechart will ask the current state's parent state to handle the event.  It
continues in the manner until it either finds an ancestore state which can
handle the event, or it will log a warning to let the developer know that no
state was able to handle it. You can see this warning, as well as other
informational messages (such as state transitions) by turning on tracing on the
statechart.

Let's do that now:

<javascript filename="apps/todos_two/statechart.js">
TodosTwo.statechart = SC.Statechart.create({
    
  trace: YES,   // <-- Add this line
    
  initialState: 'readyState',
    
  readyState: SC.State.plugin('TodosTwo.ReadyState')
  
});
</javascript>

Finally, let's make our TodosTwo.ReadyState handle the _someFunAction_ action:

<javascript filename="appps/todos_two/states/ready_state.js">
TodosTwo.ReadyState = SC.State.extend({
  
  enterState: function() {
    TodosTwo.getPath('mainPage.mainPane').append();
  },
    
  exitState: function() {
    TodosTwo.getPath('mainPage.mainPane').remove();
  },
  
  someFunAction: function(someParam) {
    alert(someParam);
  }

});
</javascript>

Save your files and refresh the page. When you click on the "Now we're rolling!"
label, you should see an alert. If you look at the console output, you can also
see the event being handled by the statechart, as well as the initialization and
the transition to the readyState.

h3. Moving Forward

Now that you have a solid understanding of how an application should be structured
to create maintainable code, you're ready to move on to creating a full-scale
SproutCore app!

"Part 3":/getting_started_3.html will introduce you to the full Todos application
and walk you through the process of building it from scratch. You will learn about
models, controllers and how they tie in with the statechart and views you already
love.

So go grab a hot cup of joe, and dive in to
"Getting Started: Part 3":/getting_started_3.html.

h3. Changelog

* May 5, 2011: initial version by "Piotr Sarnacki":credits.html#drogus
* May 9, 2011: Stylistic edits by "Tom Dale":credits.html#tomdale
* February 27, 2012: rewrite for SproutCore 1.8 by the 1.8 release sprint team, including the following who worked on this task: "Tim Evans":credits.html#tce, "Tyler Keating":credits.html#publickeating, "Maurits Lamers":credits.html#mauritslamers, "Jeff Pittman":credits.html#geojeff, "Topher Fangio":credits.html#topherfangio

