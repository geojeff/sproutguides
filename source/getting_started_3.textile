h2. Getting Started: Part 3

In this guide, you will create a SproutCore "to-do" app called TodosThree, learning the following:

* how an app is organized into views, controllers, a statechart, and models,
* how bindings and actions coordinate views with a controller system, which includes a statechart,
* how the controller system ties to models,
* how SproutCore contains powerful programming constructs.

endprologue.

h3. Following Along

You have learned in previous guides how to use sc-gen to make a project directory and to create apps in the project apps directory. You have learned how to run sc-server in the project directory, and how to view apps in a local browser at localhost:4020/. You have learned about SproutCore app concepts, including the use of a buildfile and of views and a statechart. We will build on that foundation to produce a TodosThree app with components of a best-practices SproutCore app.

You would benefit from carefully following the instructions in this guide to create directories, to type in code (or to copy and paste it), because it will register in your mind solidly. The presentation is written as if you would add the app in this manual fashion, although you surely might prefer instead the following options to get the finished source code:

* download a compressed file and explode it in your project's apps/ directory. [TODO] link

* access application on "Github":https://github.com/sproutcore/, and clone it into your project's apps/ directory. [TODO] link

To see TodosThree in action, click "here":http://github/sproutcore/sproutcore. [TODO] link to TodosThree

There is a screencast available on "Vimeo":http://vimeo.com. [TODO] [ATTN: geojeff, who will use ScreenFlow to make a new one]

INFO: This guide attempts to strike a matter-of-fact tone that doesn't sugar-coat complexity too much, but tries not to overwhelm. If you need help, please ask questions in IRC or on the mailing list, with references to the numeric heading number for relevant sections of this guide page.

h3. Creating A TodosThree Application

Here is a screen capture of the completed application: [TODO] need TodosThree screen capture image here.

The TodosThree app looks simple. It has toolbars at the top and bottom. It has a text field near the top, where a user types in a new todo. It has a list of already added todos. Even such a simple-looking app like this involves the use of intelligent SproutCore programming.

We can describe these intelligent aspects, generally, as the "system of connections" or, in the manner an electrician would use, as the "wiring diagram." SproutCore apps have _bindings_ and between properties of various components of the user interface and those of underlying machinery, and _actions_ coordinated with _states_. 

You see the components of the user interface: checkboxes, buttons, text fields, list views, etc. We'll be looking at the underlying machinery.

This will be the directory structure for the TodosThree app:

* *getting_started/* - The project directory, for holding several apps.
** *Buildfile*
** *README.md*
** *apps/*
*** *todos_three/*
**** *Buildfile*
**** *core.js*
**** *main.js*
**** *theme.js*
**** *statechart.js*
**** *states/*
***** *starting.js*
***** *logging_in.js*
***** *loading_data.js*
***** *showing_app.js*
**** *resources/*
***** *loading.rhtml*
***** *main_page.js*
***** *_theme.css*
***** *body.css*
***** *header.css*
***** *new_todo.css*
***** *todo_item.css*
**** *views/*
***** *todo_item.js*
**** *controllers/*
***** *todos.js*
***** *completed_todos.js*
**** *models/*
***** *todo.js*
**** *en/*
***** *strings.js*
****** *fixtures/*
******* *todo.js*

Here is that directory structure again, with descriptions for each item:

* *getting_started/*
** *Buildfile*             | _Configuration for the project_ 
** *README.md*             | _Describes your app and how to use it_
** *apps/*
*** *todos_three/*
**** *Buildfile*           | _Configuration for the TodosThree app_
**** *core.js*             | _TodosThree app creation code_
**** *main.js*             | _Adds a data store, and calls the TodosThree.mainPage view_
**** *theme.js*            | _Adds a TodosThree.Theme based on the SproutCore Ace theme_
**** *statechart.js*       | _Contains main app states and substates_
**** *states/*
***** *starting.js*        | _A single state, the STARTING state, which plugs in to the app's statechart_
***** *logging_in.js*      | _The LOGGING_IN state (not used in Todos, but there for illustration)_
***** *loading_data.js*     | _The LOADING_DATA state, where data is loaded, and the UI configured_
***** *showing_app.js*     | _The SHOWING_APP state, the general state for responding to user actions_
**** *resources/*
***** *loading.rhtml*      | _A short html file to show when the app is loading_
***** *main_page.js*       | _The TodosThree.mainPage view_
***** *_theme.css*         | _Contains per directory theme setup_
***** *body.css*           | _Defines css for default page content_
***** *header.css*         | _Defines css for the top toolbar_
***** *new_todo.css*       | _Defines css for the new todo title text field_
***** *todo_item.css*      | _Defines css for todo items in the main list view_
**** *views/*
***** *todo_item.js*       | _TodoItem code for a checkbox and a title_
**** *controllers/*
***** *todos.js*           | _TodosThree.todosController, an SC.ArrayController to hold todo items_
***** *completed_todos.js* | _TodosThree.completedTodosController, another SC.ArrayController_
**** *models/*
***** *todo.js*            | _TodosThree.Todo, the definition of the Todo SC.Record type for the app_
**** *en/*                 | _An English language data directory_
***** *strings.js*         | _Definitions of user interface words in English_
****** *fixtures/* 
******* *todo.js*          | _Fixtures data (for testing the app without hooking to a database_

NOTE: You see that SproutCore is a powerful system, challenging to master, but not so difficult to learn, provided that we take it one step at a time.

We can use the sc-gen command again, to create part of the directory structure shown above for our TodosThree app:

<shell>
$ pwd (This means "print working directory" -- it shows you where you are)
    ~/development/getting_started

$ sc-gen statechart_app TodosThree

 ~ Created directory at apps
 ~ Created directory at apps/todos_three
 ~ Created file at apps/todos_three/Buildfile
 ~ Created file at apps/todos_three/core.js
 ~ Created file at apps/todos_three/main.js
 ~ Created directory at apps/todos_three/resources
 ~ Created file at apps/todos_three/resources/_theme.css
 ~ Created file at apps/todos_three/resources/loading.rhtml
 ~ Created file at apps/todos_three/resources/main_page.js
 ~ Created file at apps/todos_three/statechart.js
 ~ Created directory at apps/todos_three/states
 ~ Created file at apps/todos_three/states/ready_state.js
 ~ Created file at apps/todos_three/theme.js

Your application target is now ready to use!

</shell>

We work through the app, directory by directory, file by file to edit those files and add other needed directories and files. 

h4. The App Root Directory

There are four .js files in the TodosThree app root directory (~/development/getting_started/apps/todos_three/):

|_. theme.js |_. core.js |_. main.js |_. statechart.js |


Edit these files to assure their content matches that given in the following sections:

h5. theme.js (app root directory)

<javascript filename="in apps/todos_three/theme.js">
TodosThree.Theme = SC.AceTheme.create({
  name: 'todos'
});

SC.Theme.addTheme(TodosThree.Theme);

SC.defaultTheme = 'todos';
</javascript>

TodosThree.Theme is a derivative of SC.AceTheme, a very nice professional theme. You can override parts of the Ace theme as you wish, or switch it out entirely. TodosThree.Theme is registered with the system, and a default 'todos' namespace is created.

h5. core.js (app root directory)

<javascript filename="in apps/todos_three/core.js">
TodosThree = SC.Application.create(
  /** @scope TodosThree.prototype */ {
 
  NAMESPACE: 'Todos',
  VERSION: '0.1.0',
 
  store: SC.Store.create().from(SC.Record.fixtures),
  storeType: 'FromFixtures'
});
</javascript>

The code in core.js sets up TodosThree as an instance of SC.Application.

The TodosThree namespace is TodosThree: TodosThree.mainPage, TodosThree.todosController, etc.

A data store is created from SC.Record.fixtures, which is a way to simulate a real database through reading data given in a fixtures javascript file, which we'll add in a later step. 

The storeType property is set to 'FromFixtures'.

h5. main.js (app root directory)

<javascript filename="in apps/todos_three/main.js">
TodosThree.main = function main() {
  TodosThree.statechart.initStatechart();
};
 
function main() { TodosThree.main(); }
</javascript>

[TODO] sc-gen for statechart creates a main.js with:  SC.RootResponder.responder.set('defaultResponder', statechart); -- do we need this?

main.js for TodosThree is very simple, with only a line to initialize the statechart. In a larger app, there might be global singleton objects and utility functions generally needed by an app.

h5. statechart.js (app root directory)

<javascript filename="in apps/todos_three/statechart.js">
TodosThree.statechart = SC.Statechart.create({
 
  rootState: SC.State.design({
    initialSubstate: "STARTING",
 
    STARTING: SC.State.plugin('TodosThree.STARTING'),
      
    LOGGING_IN: SC.State.plugin('TodosThree.LOGGING_IN'),
      
    LOADING_DATA: SC.State.plugin('TodosThree.LOADING_DATA'),
      
    SHOWING_APP: SC.State.plugin('TodosThree.SHOWING_APP')
  })
});
</javascript>

The statechart is a defining characteristic of a SproutCore app. Discrete states in a statechart and the transitions between them allow a clean and simple design. In the TodosThree app statechart, the initial state is STARTING, a not-so-imaginative name! 

There are four states in the TodosThree statechart: STARTING, LOGGING_IN, LOADING_DATA, and SHOWING_APP. These are defined in individual files in the states directory.

h4. The States Directory

Code for individual states is held in a states directory:

<shell>
$ pwd 
    ~/development/getting_started/apps/todos_three/
$ cd states
</shell> 

sc-gen created a file called ready_state.js in the states directory. We aren't going to use it for the TodosThree app, because we'll need several states.

Delete ready_state.js in the apps/todos_three/states directory:

<shell>
$ pwd 
    ~/development/getting_started/apps/todos_three/states
$ rm ready_state.js
</shell> 

Files to add in the apps/todos_three/states directory are:

|_. starting.js |_. logging_in.js |_. loading_data.js |_. showing_app.js |

h5. STARTING State

<javascript filename="in apps/todos_three/states/starting.js">
TodosThree.STARTING = SC.State.design({
  enterState: function() {
    if (TodosThree.get('storeType') === 'FromSomeBackendDatasource') {
      this.gotoState('LOGGING_IN');
    } else if (TodosThree.get('storeType') === 'FromFixtures') {
      this.gotoState('LOADING_DATA');
    }
  },
 
  exitState: function() {
    // Nothing to worry about here.
  }
});
</javascript>

NOTE: There are different conventions for naming states. The style used here makes the state names prominent. Some people like to camel-case the state names.

When the statechart is initialized from TodosThree.main(), program control will go to the STARTING state, specifically to its enterState() function, where there is a check for the storeType. storeType was set to be 'FromFixtures' in core.js, where the data store is instantiated. (Recall that using fixtures data as the datasource is a way to simulate a connection to a real database). You see in the if-else block of STARTING/enterState() that, because storeType === 'FromFixtures', the gotoState() call moves control directly to the LOADING_DATA state, not the LOGGING_IN state, which we won't use in the TodosThree app. 

h5. LOGGING_IN State

<javascript filename="in apps/todos_three/states/logging_in.js">
TodosThree.LOGGING_IN = SC.State.design({             
  initialSubstate: "SHOWING_LOGIN",
 
  SHOWING_LOGIN: SC.State.design({
 
    enterState: function() {
    },
 
    exitState: function() {
    },
 
    authenticate: function() {
    }
  })
});
</javascript>

INFO: We won't use the LOGGING_IN state in Todos, but have it here for illustration.

h5. LOADING_DATA State

<javascript filename="in apps/todos_three/states/loading_data.js">
TodosThree.LOADING_DATA = SC.State.design({
  enterState: function() {
    TodosThree.todosController.set('content',
      TodosThree.store.find(SC.Query.local(TodosThree.Todo, { orderBy: 'timestamp DESC' })));
 
    TodosThree.completedTodosController.set('content',
      TodosThree.store.find(SC.Query.local(TodosThree.Todo, 'isCompleted = true')));
 
    this.gotoState('SHOWING_APP');
  },
 
  exitState: function() {
  }
});
</javascript>

Data content of the two array controllers in the TodosThree app are set by issuing data query find calls to the store. SC.Query.local() is used because we know we don't have to find the data remotely in the TodosThree app. We search for todos, referencing the TodosThree.Todo model (an SC.Record instance). For the primary controller, todosController, we search for all the todos, ordering them by their timestamp property. For the completedTodosController, we search for all the todos for which isCompleted is true. Then we call gotoState() to move to the SHOWING_APP state.

h5. SHOWING_APP State

<javascript filename="in apps/todos_three/states/showing_app.js">
TodosThree.SHOWING_APP = SC.State.design({
  enterState: function() {
    TodosThree.getPath('mainPage.mainPane').append();

    TodosThree.mainPage.getPath('mainPane.newTodoField.field').becomeFirstResponder();
  },

  exitState: function() {
  },

  addTodo: function (view) {
    var todo = (view.get('value') || '').trim();
    if (todo !== '') {
      TodosThree.store.createRecord(TodosThree.Todo, {
        title: todo,
        timestamp: SC.DateTime.create()
      });
      view.set('value', '');
    }
  },

  clearCompletedTodos: function () {
    TodosThree.completedTodosController.invoke('destroy');
  }
});
</javascript>

In the SHOWING_APP/enterState() function the mainPage view is appended, which causes it to show in the browser. We want a blinking cursor in the new todo text field. This is accomplished by setting this field to become first responder in the events system.

This state handles two actions, addTodo and clearCompletedTodosThree. There are references to parts of the view code that will become clear after we add the resources directory, with the mainPage view and associated files, and other view and system components. Look back to the state and statechart code as we move through the rest of the guide.

h4. The Resources Directory

We've covered the highest-level parts of the app defined in the statechart. Let's add the rest. 

The mainPage view, CSS files, a theme file, and an html page live in a directory called resources.  Go to that directory now:

<shell>
$ pwd 
    ~/development/getting_started/apps/todos_three/
$ cd resources
</shell> 

Files to add in the apps/todos_three/resources directory are:

|_. main_page.js |_. header.css |_. body.css |_. new_todo.css |_. todo_item.css |_. _theme.css |_. loading.rhtml |

h5. main_page.js (resources directory)

<javascript filename="in apps/todos_three/resources/main_page.js">
require('views/todo_item');

TodosThree.mainPage = SC.Page.design({

  mainPane: SC.MainPane.design({
    childViews: ['header', 'newTodoField', 'todosList', 'footer'],
    defaultResponder: "TodosThree.statechart", 

    header: SC.ToolbarView.design({
      layout: { centerX: 0, width: 500, top: 0, height: 36 },

      childViews: ['title', 'completeAll'],

      completeAll: SC.CheckboxView.design(SC.AutoResize, {
        autoResizePadding: { width: 47 },
        localize: YES,
        title: '_Mark all as done',
        valueBinding: 'TodosThree.completedTodosController.areAllCompleted'
      }),

      title: SC.LabelView.design({
        layout: { left: 0, right: 0, top: 0, bottom: 0 },

        totalTodoBinding: SC.Binding.oneWay('TodosThree.todosController.length'),
        completedTodosBinding: SC.Binding.oneWay('TodosThree.completedTodosController.length'),

        value: function () {
          var leftTodo = this.get('totalTodo') - this.get('completedTodos');
          return 'TodosThree (%@)'.loc(leftTodo);
        }.property('totalTodo', 'completedTodos').cacheable()
      })
    }),

    newTodoField: SC.View.design({
      classNames: ['new-todo'],
      layout: { centerX: 0, width: 500, top: 36, height: 36 },
      childViews: ['field', 'submit'],

      field: SC.TextFieldView.design({
        localize: YES,
        hint: '_What needs to be done?'
      }),

      submit: SC.ButtonView.design(SC.AutoResize, {
        controlSize: SC.HUGE_CONTROL_SIZE,
        layout: { right: 12, height: 30, centerY: 0, zIndex: 100 },
        localize: YES,
        title: '_Add',
        action: 'addTodo',
        valueBinding: '.parentView.field.value',
        isDefaultBinding: '.parentView.field*focused'
      })
    }),
    
    todosList: SC.ScrollView.design({
      layout: { centerX: 0, width: 500, top: 72, bottom: 36 },
      contentView: SC.ListView.design({
        contentBinding: SC.Binding.oneWay('TodosThree.todosController'),
        rowHeight: 36,
        exampleView: TodosThree.TodoItemView
      })
    }),
        
    footer: SC.ToolbarView.design({
      layout: { centerX: 0, width: 500, bottom: 0, height: 36 },

      childViews: ['clearCompletedTodos'],
      clearCompletedTodos: SC.ButtonView.design(SC.AutoResize, {
        controlSize: SC.HUGE_CONTROL_SIZE,
        layout: { left: 14, height: 30, centerY: 0 },
        isEnabledBinding: SC.Binding.oneWay('TodosThree.completedTodosController.length').bool(),
        localize: YES,
        title: '_Clear completed todos',
        action: 'clearCompletedTodos'
      })
    })
  })

});
</javascript>

There are four parts to the TodosThree mainPage view: a header and footer, and between them are a newTodoField and a todosList. A user types a new todo in the newTodoField, and when they click the submit button, labeled 'Add', the new todo is added by means of the todosController's addTodo() function. The new todo will, in turn, show up in the todosList. How does this happen? Look at the lines that have Binding in the property names. When you write user interface element code, you "wire up" these connections with such binding instructions. 

h6. Toolbars in header and footer

The header view is an SC.ToolbarView with two child views: a completeAll checkbox view and a title label view. The valueBinding property of the checkbox is tied to an areAllCompleted() function in the completedTodosController, which answers that question -- if yes, then the completeAll checkbox will show as checked. This is a two-way binding, so it works in reverse. If the user clicks the completeAll checkbox, then areAllCompleted() will set isCompleted to true for all todos. Yes, that makes areAllCompleted() a very special type of function, called a computed property. As you'll see, computed properties give this power in more than one context.

The footer view has a single child view, clearCompletedTodos, a button whose action is tied to the clearCompletedTodos() function in the completedTodosController. The isEnabledBinding property has a one-way binding (faster, if you don't need two-way, reciprocal updating) to the length of the completedTodosController, which is an SC.ArrayController. If its length is 0, then isEnabled is false and the button will not be active (If there aren't any todos, there is nothing to clear).

h6. newTodoField

The newTodoField view contains a text field called field and a submit button. The submit button has two properties that are bound to the associated text field. The valueBinding property is bound to field.value, which of course is the text the user enters. Note the use of .parentView in the valueBinding definition. In this context, parentView refers to the newTodoField view, which has the field and submit child views. The isDefaultBinding property works in similar fashion, but you note an asterisk in front of a reference to 'focused', which is one of the boolean properties available for a text field. The asterisk is a convention that means what an asterisk often means -- if the text field has any type of focus at all, keyboard or mouse, then 'focused' will be true. 
 
h6. todosList

The todosList view follows the SproutCore idiom for wrapping an SC.ListView in an SC.ScrollView. The contentBinding property of the list is set to TodosThree.todosController. The exampleView property introduces a concept very important for SproutCore: views can be defined in separate javascript files, often held in a views directory, and included where they are needed. exampleView is set to TodosThree.TodoItemView, which necessitates a require statement at the top of the file: require('views/todo_item');. TodoItemView has a checkbox and label. We'll add it after we add the views directory later.

h5. _theme.css (resources directory)

<css filename="in apps/todos_three/resources/_theme.css">
/*
  This defines the global $theme variable for use inside your CSS.
  The $theme variable holds the CSS class names for your theme.
  
  You can then theme your app by using CSS like this:

      $theme.button {
        color: blue;
        @include slices('white-button.png', $left: 3, $right: 3);
      }
  
  Any _theme.css file is prepended to all files inside its directory,
  and any subdirectories that don't define their own _theme.css file.
  
  This allows you to give different directories different values for
  $theme if you wish.
*/
$theme: '.ace.todos';
</css>

The underscore starting the name of _theme.css is a dead giveaway that it must apply in some special way to the theming system. It defines $theme to be our Ace-derived theme, ace.todos. You'll see $theme used in individual content CSS files.

h5. Content CSS files

You can add a single CSS file in your resources directory, or you can add many small ones. For the TodosThree app, we'll choose the many-small-ones approach. In these CSS files, where you see something like $theme.sc-text-field-view, the sc- prefix indicates an override of the sc- CSS definitions in the Ace theme. 

NOTE: CSS is an art unto itself, an important side of doing SproutCore development and building views.

Names of the files indicate their applicability: header.css, body.css, new_todo.css, and todo_item.css.

h6. header.css (resources directory)

<css filename="in apps/todos_three/resources/header.css">
$theme.toolbar {
  .checkbox {
    .button {
      left: 13px;
      top: 50%;
      margin-top: -8px;
    }

    .label {
      left: 47px;
      line-height: 36px;
    }
  }

  .sc-label-view {
    text-align: right;
    line-height: 36px;
    font-weight: bold;
    font-size: 18px;
    padding-right: 12px;
  }
}
</css>

h6. body.css (resources directory)

<css filename="in apps/todos_three/resources/body.css">
body {
  -webkit-font-smoothing: antialiased;
  text-rendering: optimizelegibility;
}

.sc-pane {
  -webkit-transform: none;
}
</css>

h6. new_todo.css (resources directory)

<css filename="in apps/todos_three/resources/new_todo.css">
$theme.new-todo {
  background-color: #FFF;
}

$theme.sc-text-field-view {
  background-color: transparent;
  font-size: 14px;

  .padding {
    left: 14px;
  }
}
</css>

h6. todo_item.css (resources directory)

<css filename="in apps/todos_three/resources/todo_item.css">
$theme.todo-item {
  .button {
    left: 13px;
    top: 50%;
    margin-top: -8px;
  }

  .label {
    left: 47px;
    line-height: 36px;
  }

  &.sel {
    background-color: white;
    color: #AAA;
    text-decoration: line-through;
  }
}
</css>

h5. loading.rhtml (resources directory)

SproutCore apps can weigh in north of the welterweight class, so while the app is loading we may need to show a loading indicator. For TodosThree we don't have to worry, but in larger apps, this file could need some attention.

<html filename="in apps/todos_three/resources/loading.rhtml">
<% content_for :loading do %>
<% # Any HTML in this file will be visible on screen while your page loads
   # its application JavaScript.  SproutCore applications are optimized for 
   # caching and startup very fast, so your users will often only see this 
   # content for a brief moment on their first app load, if at all.
%>
<p class="loading">Loading...<p>

<% end %>
</html>

h4. The Views Directory

sc-gen doesn't make a views directory, so we'll need to make one.

Before adding the views directory, some navigation is needed. We are still in the resources directory, so move back up to the TodosThree app root directory:

<shell>
$ pwd 
    ~/development/getting_started/apps/todos_three/resources/
$ cd ..
</shell>

Make a views directory:

<shell>
$ pwd 
    ~/development/getting_started/apps/todos_three/
$ mkdir views
$ cd views
</shell>

The views directory will contain one file: 

|_. todo_item.js |

h5. todo_item.js (views directory)

<javascript filename="in apps/todos_three/views/todo_item.js">
TodosThree.TodoItemView = SC.CheckboxView.design({
  classNames: ['todo-item'],

  valueBinding: '.content.isCompleted',

  titleBinding: SC.Binding.oneWay('.content.title')
});
</javascript>

TodoItemView is a checkbox, which has a label. You see a bit of wiring to CSS in the classNames property, an array of CSS class names. valueBinding has a reference to .content.isCompleted, prompting an explanation of the context for this view. We know that this view is defined as the exampleView property of the todos list above. The term example here means "the view to use for each list item." List items for the todos list are todos, which are defined in the TodosThree.Todo model. So, .content used in the TodoItemView definition refers to a single todo item in the list. The value of this checkbox is thus the isCompleted property of the todo associated with the given list item. Likewise, titleBinding is tied to the title property of the list item todo.

You really have to think about where this view is used to understand it, but that comes with the territory of having separate views in files in a views directory.

NOTE: It helps to name such views as SomethingItemView, because the Item part indicates the use in a list. 

h4. The Models Directory

sc-gen does not make a models directory, so we'll need to make it.

Move up to the app root directory:

<shell>
$ pwd 
    ~/development/getting_started/apps/todos_three/resources/views/
$ cd ..
</shell>

Make a models directory:

<shell>
$ pwd 
    ~/development/getting_started/apps/todos_three/
$ mkdir models
$ cd models
</shell>

SproutCore models are based on SC.Record, which offers a substantial set of data definition and processing functionality.

The models directory will contain one file:

|_. todo.js |

h5. todo.js (models directory)

<javascript filename="in apps/todos_three/models/todo.js">
require('core');

TodosThree.Todo = SC.Record.extend({
  timestamp: SC.Record.attr(SC.DateTime),
  isCompleted: SC.Record.attr(Boolean),
  title: SC.Record.attr(String)
});
</javascript>

The Todo model has three properties: timestamp, isCompleted, and title. All are defined using the SC.Record.attr() helper (convenience) function, where builtin javascript types and Sproutcore types may be specified. There is much more that could be done in these property definitions, but for Todos, the basic types and their defaults will suffice.

h4. The Controllers Directory

sc-gen does not make a controllers directory, so we'll make it.

Move up to the TodosThree app root directory:

<shell>
$ pwd 
    ~/development/getting_started/apps/todos_three/models
$ cd ..
</shell>

Make a controllers directory:

<shell>
$ pwd 
    ~/development/getting_started/apps/todos_three/
$ mkdir controllers
$ cd controllers
</shell>

Controllers tied to models mediate communication with views. We'll need a couple in the TodosThree app.

The controllers directory will contain two files: 

|_. todos.js |_. completed_todos.js |

h5. todos.js (controllers directory)

<javascript filename="in apps/todos_three/controllers/todos.js">
require('core');
 
// A controller that will provide a list of all of the todos.
TodosThree.todosController = SC.ArrayController.create({
});
</javascript>

h5. completed_todos.js (controllers directory)

<javascript filename="in apps/todos_three/controllers/completed_todos.js">
require('controllers/todos');

TodosThree.completedTodosController = SC.ArrayController.create({

  totalTodosBinding: SC.Binding.oneWay('TodosThree.todosController.length'),

  areAllCompleted: function (k, v) {
    if (v !== undefined) {
      TodosThree.todosController.setEach('isCompleted', v);
    }
    return this.get('length') === this.get('totalTodos');
  }.property('length', 'totalTodos').cacheable()
});
</javascript>

The todosController has the simplest default definition as an SC.ArrayController. An array controller has a default _content_ reference to the data: you don't see a content property defined here, but take note, because you'll see prevalent use of the content property in all things controller.

The completeTodosController is another array controller with a property, totalTodosBinding, and a function, areAllCompleted(). 

totalTodosBinding is simple enough. It is a one-way binding (we are "pulling", we don't care about pushing back) to the length of the todosController array controller. We need a local reference to this length, because we are about to do something impressive, in part based on it.

areAllCompleted() is a function, but a very special type of function, called a computed property. Note the .property() call hanging on the end of the function definition. This gives 'length' and 'totalTodos' as parameters, then tacks on .cacheable(). First, the parameters, which are references to local properties for this context, which is the array controller body. We know we have a 'length' property -- this is an array controller. But what gives with the use of the 'totalTodos' reference, isn't the property called totalTodosBinding? Ah, the answer is that anytime Binding is appended to a property name, you have a kind of dual-property arrangement. The actual property is, in fact, totalTodosThree. In defining totalTodosBinding, we essentially say, get the value of totalTodosThree from this other source. That covers the background on mechanics of property names, now to address what .property('length', 'totalTodos').cacheable() accomplishes. It means:

  "Base this computed property on the length and totalTodosThree properties, and update it if either of them changes, and, oh, by the way, please cache the values while you are at it, so unnecessary updates aren't performed." 

There is more to explain about the working of this computed property. What are the k and v parameters, and what does the internal code do? k and v are key and value. On a call, if v is a defined value, then the totalTodosThree value is being changed. This is a mandate to try to mark all todos as completed by this value. That's the name of the function/computed property: areAllCompleted. If a call is made to set it, then the body of the function needs to update the data accordingly. If v evaluates to true, then isCompleted for each todo item will be set and all the checkboxes will be checked in the list. That explains what the if block does. 

Notice the return at the end of the areAllCompleted computed property function. We return the result of a test comparing the length of completed todos array (the local 'length') to the length of the todos array (the local 'totalTodos', which is bound to an external source, the full todosController array). If these lengths are the same, then all todos have been marked as completed, otherwise no. 

So, a computed property used in this way is both a setter and a getter. Once you get the hang of making these you realize the benefit: automatic updating and caching for efficiency.

h4. The En Directory

sc-gen does not make an en directory, nor its fixtures directory. We'll make these.

Move up to the TodosThree app root directory:

<shell>
$ pwd 
    ~/development/getting_started/apps/todos_three/controllers/
$ cd ..
</shell>

Make an en directory:

<shell>
$ pwd 
    ~/development/getting_started/apps/todos_three/
$ mkdir en
$ cd en
</shell>

h5. strings.js (en directory)

The en directory will contain one file: 

|_. strings.js |

<javascript filename="in apps/todos_three/en/strings.js">
SC.stringsFor('en', {
  '_Mark all as done': 'Mark all as done',
  '_TodosThree (%@)': 'TodosThree (%@)',
  '_Clear completed todos': 'Clear completed Todos',
  '_Add': 'Add',
  '_What needs to be done?': 'What needs to be done?'
});
</javascript>

h5. The Fixtures Directory

While still in the en directory, make a fixtures directory:

<shell>
$ pwd 
    ~/development/getting_started/apps/todos_three/en/
$ mkdir fixtures
$ cd fixtures
</shell>

The fixtures directory will contain one file: 

|_. todo.js |

h6. todo.js (fixtures directory)

<javascript filename="in apps/todos_three/en/fixtures/todo.js">
require('models/todo');

TodosThree.Todo.FIXTURES = [
 {
   guid: 0,
   isCompleted: YES,
   title: 'Add a SHOWING_APP state'
 },
 {
   guid: 1,
   isCompleted: YES,
   title: 'Edit the buildfile'
 },
 {
   guid: 2,
   isCompleted: YES,
   title: 'Add a TodosThree app'
 },
 {
   guid: 3,
   isCompleted: YES,
   title: 'Install SproutCore'
 }
];
</javascript>

h4. Running the App

With all that work done (or if you downloaded the code or cloned it from git) we can run the app, which we should do from the project root directory, where the project Buildfile lives:

<shell>
$ pwd 
    ~/development/getting_started/apps/todos_three/en/fixtures
$ cd ../../../..
</shell>

And run it!

<shell>
$ pwd 
    ~/development/getting_started/
$ sc-server
</shell>

Visit http://localhost:4020/ in your favorite modern browser and you should see a list of apps, including TodosThree. 


* March 1, 2011: initial version by "Tom Dale":credits.html#tomdale and "Yehuda Katz":credits.html#wycats
* March 2, 2011: fixed formmating and added paths to filenames by "Topher Fangio":credits.html#topherfangio and "Peter Wagenet":credits.html#pwagenet
* March 22, 2011: cleaned up demo based on new features by "Yehuda Katz":credits.html#wycats
* April 11, 2011: consistently use view classes and extend, update to reflect better Handlebars integration by "Yehuda Katz":credits.html#wycats and "Tom Dale":credits.html#tomdale
* May 6, 2011: clarifications, minor inconsistency fixes, updated CSS for older browsers, plus new mobile section by "Tyler Keating":credits.html#publickeating
* May 9, 2011: update for recent changes in SproutCore 1.6 by "Tom Dale":credits.html#tomdale and "Yehuda Katz":credits.html#wycats
* February 27, 2012: rewrite for SproutCore 1.8 by the 1.8 release sprint team, including the following who worked on this task: "Tim Evans":credits.html#tce, "Topher Fangio":credits.html#topherfangio, "Tyler Keating":credits.html#publickeating, "Maurits Lamers":credits.html#mauritslamers, "Jeff Pittman":credits.html#geojeff

