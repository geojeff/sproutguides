h2. Getting Started: Part 3

In this guide, you will create a SproutCore "to-do" app called TodosThree, learning the following:

* How a more substantial, best-practices app takes shape,
* How an app is organized into views, controllers, a statechart, and models,
* How bindings and actions coordinate views with a controller system, which includes a statechart,
* How the controller system ties to models,
* How SproutCore contains powerful programming constructs.

endprologue.

h3. Following Along

You have learned in previous guides how to use *sproutcore gen* to make a project directory and to create apps in the project apps directory. You have learned how to run *sproutcore server* in the project directory, and how to view apps in a local browser at localhost:4020/. You have learned about SproutCore app concepts, including the use of a buildfile and of views and a statechart. We will build on that foundation to produce a TodosThree app with components of a best-practices SproutCore app.

You would benefit from carefully following the instructions in this guide to create directories, to type in code (or to copy and paste it), because it will register in your mind solidly. The presentation is written as if you would add the app in this manual fashion, although you surely might prefer instead the following options to get the finished source code:

* download a compressed file and explode it in your project's apps/ directory. [TODO] link

* clone from "Github":https://github.com/sproutcore/ into your project's apps/ directory. [TODO] link

To see TodosThree in action, click "here":http://github/sproutcore/sproutcore. [TODO] link to TodosThree

There is a screencast available on "Vimeo":http://vimeo.com. [TODO] [ATTN: geojeff, who will use ScreenFlow to make a new one]

INFO: This guide attempts to strike a matter-of-fact tone that doesn't sugar-coat complexity too much, but tries not to overwhelm. If you need help, please ask questions in IRC or on the mailing list, with references to the numeric heading number for relevant sections of this guide page.

h3. Creating A TodosThree Application

Here is a screen capture of the completed application: [TODO] need TodosThree screen capture image here.

The TodosThree app looks simple. It has toolbars at the top and bottom. It has a text field near the top, where a user types in a new todo. It has a list of already added todos. Even such a simple-looking app like this involves the use of intelligent SproutCore programming.

We can describe these intelligent aspects, generally, as the "system of connections" or, in the manner an electrician would use, as the "wiring diagram." SproutCore apps have _bindings_ between various components of the user interface and those of underlying machinery, the normal complement of events in a web app, and _actions_ coordinated with _states_. 

You see the components of the user interface in the screen capture: checkboxes, buttons, text fields, list views, etc. We'll be looking at the underlying machinery.

This will be the directory structure for the TodosThree app:

* *getting_started/* - The project directory, for holding several apps.
** *Buildfile*
** *README.md*
** *apps/*
*** *todos_three/*
**** *Buildfile*
**** *core.js*
**** *main.js*
**** *theme.js*
**** *statechart.js*
**** *states/*
***** *starting.js*
***** *logging_in.js*
***** *loading_data.js*
***** *showing_app.js*
**** *resources/*
***** *loading.rhtml*
***** *main_page.js*
***** *_theme.css*
***** *body.css*
***** *header.css*
***** *new_todo.css*
***** *todo_item.css*
**** *views/*
***** *todo_item.js*
**** *controllers/*
***** *todos.js*
***** *completed_todos.js*
**** *models/*
***** *todo.js*
**** *fixtures/*
***** *todo.js*

Here is that directory structure again, with descriptions for each item:

* *getting_started/*
** *Buildfile*                         | _Configuration for the project_ 
** *README.md*                         | _Describes your app and how to use it_
** *apps/*
*** *todos_three/*
**** *Buildfile*                       | _Configuration for the TodosThree app_
**** *core.js*                         | _TodosThree app creation code_
**** *main.js*                         | _Adds a data store, and calls the TodosThree.mainPage view_
**** *theme.js*                        | _Adds a TodosThree.Theme based on the SproutCore Ace theme_
**** *statechart.js*                   | _Contains main app states and substates_
**** *states/*
***** *ready.js*                       | _A single state, the READY state, which plugs in to the app's statechart_
***** *logging_in.js*                  | _The LOGGING_IN state (not used in TodosThree, but there for illustration)_
***** *showing_app.js*                 | _The SHOWING_APP state, the general state for responding to user actions_
***** *destroying_completed_todos.js*  | _The DESTROYING_COMPLETED_TODOS state_
**** *resources/*
***** *loading.rhtml*                  | _A short html file to show when the app is loading_
***** *main_page.js*                   | _The TodosThree.mainPage view_
***** *_theme.css*                     | _Contains per directory theme setup_
***** *body.css*                       | _Defines css for default page content_
***** *header.css*                     | _Defines css for the top toolbar_
***** *new_todo.css*                   | _Defines css for the new todo title text field_
***** *todo_item.css*                  | _Defines css for todo items in the main list view_
**** *views/*
***** *todo_item.js*                   | _TodoItem code for a checkbox and a title_
**** *controllers/*
***** *todos.js*                       | _TodosThree.todosController, an SC.ArrayController to hold todo items_
***** *completed_todos.js*             | _TodosThree.completedTodosController, another SC.ArrayController_
**** *models/*
***** *todo.js*                        | _TodosThree.Todo, the definition of the Todo SC.Record type for the app_
**** *fixtures/* 
***** *todo.js*                        | _Fixtures data (for testing the app without hooking to a database)_

NOTE: SproutCore is a powerful system, challenging to master, but not so difficult to learn, provided that we take it one step at a time.

We can use the *sproutcore gen* command again, to create part of the directory structure shown above for our TodosThree app:

<shell>
$ pwd (This command means "print working directory" -- it shows you where you are)
    ~/development/sproutcore/getting_started

$ sproutcore gen statechart_app TodosThree

 ~ Created directory at apps
 ~ Created directory at apps/todos_three
 ~ Created file at apps/todos_three/Buildfile
 ~ Created file at apps/todos_three/core.js
 ~ Created file at apps/todos_three/main.js
 ~ Created directory at apps/todos_three/resources
 ~ Created file at apps/todos_three/resources/_theme.css
 ~ Created file at apps/todos_three/resources/loading.rhtml
 ~ Created file at apps/todos_three/resources/main_page.js
 ~ Created file at apps/todos_three/statechart.js
 ~ Created directory at apps/todos_three/states
 ~ Created file at apps/todos_three/states/ready_state.js
 ~ Created file at apps/todos_three/theme.js

Your application target is now ready to use!

</shell>

We will work through the app, directory by directory, file by file, to edit those files and to add other needed directories and files. 

h4. The App Root Directory

There are four .js files in the TodosThree app root directory (~/development/sproutcore/getting_started/apps/todos_three/):

|_. theme.js |_. core.js |_. main.js |_. statechart.js |


Edit these files to assure their content matches that given in the following sections (comments are not present in this document):

h5. theme.js (app root directory)

<javascript filename="in apps/todos_three/theme.js">
TodosThree.Theme = SC.AceTheme.create({
  name: 'todos-three'
});

SC.Theme.addTheme(TodosThree.Theme);

SC.defaultTheme = 'todos-three';
</javascript>

TodosThree.Theme is a derivative of SC.AceTheme, a very nice professional theme. You can override parts of the Ace theme as you wish, or switch it out entirely. In theme.js, TodosThree.Theme is registered with the system, and a default 'todos-three' namespace is created.

h5. core.js (app root directory)

<javascript filename="in apps/todos_three/core.js">
TodosThree = SC.Application.create(
  /** @scope TodosThree.prototype */ {
 
  NAMESPACE: 'TodosThree',
  VERSION: '0.1.0',
 
  store: SC.Store.create().from(SC.Record.fixtures),
});
</javascript>

The code in core.js sets up TodosThree as an instance of SC.Application.

The TodosThree namespace is TodosThree: TodosThree.mainPage, TodosThree.todosController, etc.

A data store is created from SC.Record.fixtures, which is a way to simulate a real database. This is done by reading JSON-formatted sample data given from a fixtures javascript file, which we'll add in a later step. 

h5. main.js (app root directory)

<javascript filename="in apps/todos_three/main.js">
TodosThree.main = function main() {
  var statechart = TodosThree.statechart;
  TodosThree.mainPage.get('field').becomeFirstResponder();
  TodosThree.statechart.initStatechart();
};
 
function main() { TodosThree.main(); }
</javascript>

main.js for TodosThree is very simple. The statechart is set as the default responder, so it gets action events. Then the statechart, the brains of the outfit, is initialized.

h5. statechart.js (app root directory)

<javascript filename="in apps/todos_three/statechart.js">
TodosThree.statechart = SC.Statechart.create({

  trace: YES,
 
  rootState: SC.State.design({
    initialSubstate: "READY",
 
    READY: SC.State.plugin('TodosThree.READY'),
      
    LOGGING_IN: SC.State.plugin('TodosThree.LOGGING_IN'),

    SHOWING_APP: SC.State.plugin('TodosThree.SHOWING_APP'),

    SHOWING_DESTROY_CONFIRMATION: SC.State.plugin('TodosThree.SHOWING_DESTROY_CONFIRMATION'),

    DESTROYING_COMPLETED_TODOS: SC.State.plugin('TodosThree.DESTROYING_COMPLETED_TODOS')
  })

});
</javascript>

The statechart is a defining characteristic of a SproutCore app. Discrete states in a statechart and the transitions between them allow a clean and simple design. In the TodosThree app statechart, the initial state is READY.

There are four states in the TodosThree statechart: READY, LOGGING_IN, SHOWING_APP, and DESTROYING_COMPLETED_TODOS. These are defined in individual files in the states directory.

h4. The States Directory

Code for individual states is held in the states directory:

<shell>
$ pwd 
    ~/development/sproutcore/getting_started/apps/todos_three/
$ cd states
</shell> 

*sproutcore gen* created a file called ready_state.js in the states directory. We are going to use it for the TodosThree app, but to make it match our file naming pattern, rename it to ready.js:

<shell>
$ pwd 
    ~/development/sproutcore/getting_started/apps/todos_three/states
$ mv ready_state.js ready.js
</shell> 

Files to edit or add in the apps/todos_three/states directory are:

|_. ready.js |_. logging_in.js |_. showing_app.js |_. destroying_completed_todos.js |

h5. READY State (replace content of renamed ready.js)

<javascript filename="in apps/todos_three/states/ready.js">
TodosThree.READY = SC.State.design({
  enterState: function() {
    if (SC.instanceOf(TodosThree.store.dataSource, SC.FixturesDataSource)) {
      TodosThree.todosController.set('content',
        TodosThree.store.find(SC.Query.local(TodosThree.Todo, { orderBy: 'timestamp DESC' })));
   
      TodosThree.completedTodosController.set('content',
        TodosThree.store.find(SC.Query.local(TodosThree.Todo, 'isCompleted = true')));
   
      this.gotoState('SHOWING_APP');
    } else {
      this.gotoState('LOGGING_IN');
    }
  },
 
  exitState: function() {
    // Nothing to worry about here.
  }
});
</javascript>

NOTE: You have seen different conventions for naming states. The style used here makes the state names prominent. Some people like to camel-case the state names.

When the statechart is initialized in the TodosThree.main() function, program control will go to the READY state, specifically to its enterState() function, where there is a check for the type of dataSource set on the store. Because it is an instance of FixturesDataSource, there is initialization of the controllers, followed by the call to move directly to the SHOWING_APP state, not to the LOGGING_IN state, which we won't use in the TodosThree app. 

Before the state transition to the SHOWING_APP state, data content of the two array controllers is set by issuing data query find calls to the store. SC.Query.local() is used because we know we don't have to find the data remotely in the TodosThree app. We search for todos, referencing the TodosThree.Todo model (an SC.Record instance). For the primary controller, todosController, we search for all the todos, ordering them by their timestamp property. For the completedTodosController, we search for all the todos for which isCompleted is true. Then we call gotoState() to move to the SHOWING_APP state.

INFO: These aren't one-time "searches." They are associations set between the 'content' property of a controller and a store.find() query. This is a very powerful construct, explaining how SproutCore apps get part of their "automatic" and "always up-to-date" aspect.

h5. LOGGING_IN State

<javascript filename="in apps/todos_three/states/logging_in.js">
TodosThree.LOGGING_IN = SC.State.design({             
  initialSubstate: "SHOWING_LOGIN",
 
  SHOWING_LOGIN: SC.State.design({
 
    enterState: function() {
    },
 
    exitState: function() {
    },
 
    authenticate: function() {
    }
  })
});
</javascript>

INFO: We won't use the LOGGING_IN state in TodosThree, but have it here for illustration.

h5. SHOWING_APP State

<javascript filename="in apps/todos_three/states/showing_app.js">
TodosThree.SHOWING_APP = SC.State.design({
  enterState: function() {
    TodosThree.getPath('mainPage.mainPane').append();

    TodosThree.mainPage.getPath('mainPane.newTodoField.field').becomeFirstResponder();
  },

  exitState: function() {
  },

  addTodo: function (view) {
    var todo = (view.get('value') || '').trim();
    if (todo !== '') {
      TodosThree.store.createRecord(TodosThree.Todo, {
        title: todo,
        timestamp: SC.DateTime.create()
      });
      view.set('value', '');
    }
  },

  clearCompletedTodos: function() {
    this.gotoState('SHOWING_DESTROY_CONFIRMATION', this);
  }
});
</javascript>

In the SHOWING_APP/enterState() function, the mainPage view is appended, which causes it to show in the browser. We want a blinking cursor in the new todo text field. This is accomplished by setting this field to become first responder in the events system.

This state handles two actions, addTodo and clearCompletedTodos. There are references to view code (view.) that will become clear after we add the resources directory, with the mainPage view and associated files, and other view and system components.

h5. DESTROYING_COMPLETED_TODOS State

<javascript filename="in apps/todos_three/states/destroying_completed_todos.js">
TodosThree.DESTROYING_COMPLETED_TODOS = SC.State.design({
  enterState: function() {
  },
 
  clearCompletedTodos: function () {
    TodosThree.completedTodosController.invoke('destroy');
  },

  cancelDestroyingCompletedTodos: function() {
    this.gotoState('SHOWING_APP');
  },

  exitState: function() {
  }
});
</javascript>

h5. SHOWING_DESTROY_CONFIRMATION State

<javascript filename="in apps/todos_three/states/showing_destroy_confirmation.js">
TodosThree.SHOWING_DESTROY_CONFIRMATION = SC.State.design({
  enterState: function() {
    var panel = TodosThree.getPath('DestroyingConfirmationPane');
    if (panel) {
      panel.append();
    }
  },
 
  exitState: function() {
    var panel = TodosThree.getPath('DestroyingConfirmationPane');
    if (panel) {
      panel.remove();
    }
    this.gotoState('SHOWING_APP');
  }
});
</javascript>


h4. The Resources Directory

We've covered the highest-level parts of the app defined in the statechart. Let's add the rest. 

The mainPage view, CSS files, a theme file, and an html page live in a directory called resources.  Go to that directory:

<shell>
$ pwd 
    ~/development/sproutcore/getting_started/apps/todos_three/
$ cd resources
</shell> 

Files to add in the apps/todos_three/resources directory are:

|_. main_page.js |_. header.css |_. body.css |_. new_todo.css |_. todo_item.css |_. _theme.css |_. loading.rhtml |

h5. main_page.js (resources directory)

<javascript filename="in apps/todos_three/resources/main_page.js">
sc_require('views/todo_item');

TodosThree.mainPage = SC.Page.design({
  field: SC.outlet('mainPane.newTodoField.field'),

  mainPane: SC.MainPane.design({
    childViews: ['header', 'newTodoField', 'todosList', 'footer'],
    defaultResponder: "TodosThree.statechart", 

    header: SC.ToolbarView.design({
      layout: { centerX: 0, width: 500, top: 0, height: 36 },

      childViews: ['title', 'completeAll'],

      completeAll: SC.CheckboxView.design(SC.AutoResize, {
        autoResizePadding: { width: 47 },
        localize: YES,
        title: '_Mark all as done',
        valueBinding: 'TodosThree.completedTodosController.areAllCompleted'
      }),

      title: SC.LabelView.design({
        layout: { left: 0, right: 0, top: 0, bottom: 0 },

        totalTodoBinding: SC.Binding.oneWay('TodosThree.todosController.length'),
        completedTodosBinding: SC.Binding.oneWay('TodosThree.completedTodosController.length'),

        value: function () {
          var leftTodo = this.get('totalTodo') - this.get('completedTodos');
          return 'TodosThree (%@)'.loc(leftTodo);
        }.property('totalTodo', 'completedTodos').cacheable()
      })
    }),

    newTodoField: SC.View.design({
      classNames: ['new-todo'],
      layout: { centerX: 0, width: 500, top: 36, height: 36 },
      childViews: ['field', 'submit'],

      field: SC.TextFieldView.design({
        localize: YES,
        hint: '_What needs to be done?'
      }),

      submit: SC.ButtonView.design(SC.AutoResize, {
        controlSize: SC.HUGE_CONTROL_SIZE,
        layout: { right: 12, height: 30, centerY: 0, zIndex: 100 },
        localize: YES,
        title: '_Add',
        action: 'addTodo',
        valueBinding: '.parentView.field.value',
        isDefaultBinding: '.parentView.field*focused'
      })
    }),
    
    todosList: SC.ScrollView.design({
      layout: { centerX: 0, width: 500, top: 72, bottom: 36 },
      contentView: SC.ListView.design({
        contentBinding: SC.Binding.oneWay('TodosThree.todosController'),
        rowHeight: 36,
        exampleView: TodosThree.TodoItemView
      })
    }),
        
    footer: SC.ToolbarView.design({
      layout: { centerX: 0, width: 500, bottom: 0, height: 36 },

      childViews: ['clearCompletedTodos'],
      clearCompletedTodos: SC.ButtonView.design(SC.AutoResize, {
        controlSize: SC.HUGE_CONTROL_SIZE,
        layout: { left: 14, height: 30, centerY: 0 },
        isEnabledBinding: SC.Binding.oneWay('TodosThree.completedTodosController.length').bool(),
        localize: YES,
        title: '_Clear completed todos',
        action: 'clearCompletedTodos'
      })
    })
  })

});
</javascript>

There are four parts to the TodosThree mainPage view: a header and footer, and between them are a newTodoField and a todosList. A user types a new todo in the newTodoField, and when they click the submit button, labeled 'Add', the new todo is added by means of the todosController's addTodo action. The new todo will show up in the todosList. How does this happen? Look at the lines that have Binding in the property names. When you write user interface element code, you "wire up" these connections with such binding instructions. 

h6. Toolbars in header and footer

The header view is an SC.ToolbarView with two child views: a completeAll checkbox view and a title label view. The valueBinding property of the checkbox is tied to an areAllCompleted() function in the completedTodosController, which answers that question -- if yes, then the completeAll checkbox will show as checked. This is a two-way binding, so it works in reverse. If the user clicks the completeAll checkbox, then areAllCompleted() will set isCompleted to true for all todos. That makes areAllCompleted() a very special type of function, called a computed property.

INFO: Computed properties are cool.

The footer view has a single child view, clearCompletedTodos, which is a button whose action is the clearCompletedTodos action in the SHOWING_APP state. The isEnabledBinding property has a one-way binding (faster, if you don't need two-way, reciprocal updating) to the length of the completedTodosController array. If its length is 0, then isEnabled is false and the button will not be active -- if there aren't any todos, there is nothing to clear.

h6. newTodoField

The newTodoField view contains a text field called field and a submit button. The submit button has two properties that are bound to the associated text field. The valueBinding property is bound to field.value, which is the text the user enters. Note the use of .parentView in the valueBinding definition. In this context, parentView refers to the newTodoField view, which contains the field and submit child views. The isDefaultBinding property works in similar fashion, but you note an asterisk in front of a reference to 'focused', which is one of the boolean properties available for a text field. The asterisk is a convention that means what an asterisk often means -- if the text field has any type of focus at all, keyboard or mouse, then 'focused' will be true. 

NOTE: Property path syntax -- e.g., the . and * in .parentView.field*focused -- is something you have to look up repeatedly until you are comfortable. There are nuances to learn.
 
h6. todosList

The todosList view follows the SproutCore idiom for wrapping an SC.ListView inside an SC.ScrollView. The contentBinding property of the list is set to TodosThree.todosController. 

The exampleView property illustrates a concept very important for SproutCore, one that you learned in a previous guide: views can be defined in separate javascript files, often held in a views directory, and included where they are needed. exampleView is set to TodosThree.TodoItemView, which necessitates the sc_require statement at the top of the file: sc_require('views/todo_item');. TodoItemView has a checkbox and label. We'll add it when we add the views directory later.

NOTE: The load order for javascript files will be alphabetical, unless otherwise controlled with sc_require(). Sometimes you get lucky on the default file loading order, if you omit a sc_require() statement. Sometimes you don't, and you will get a dependency error.

h5. _theme.css (resources directory)

<css filename="in apps/todos_three/resources/_theme.css">
/*
  This defines the global $theme variable for use inside your CSS.
  The $theme variable holds the CSS class names for your theme.
  
  You can then theme your app by using CSS like this:

      $theme.button {
        color: blue;
        @include slices('white-button.png', $left: 3, $right: 3);
      }
  
  Any _theme.css file is prepended to all files inside its directory,
  and any subdirectories that don't define their own _theme.css file.
  
  This allows you to give different directories different values for
  $theme if you wish.
*/
$theme: '.ace.todos-three';
</css>

The underscore starting the name of _theme.css is a dead giveaway that it must apply in some special way to the theming system. It defines $theme to be our Ace-derived theme, ace.todos-three. You'll see $theme used in individual content CSS files.

h5. Content CSS files

You can add a single CSS file in your resources directory, or you can add many small ones. For the TodosThree app, we'll choose the many-small-ones approach. In these CSS files, where you see something like $theme.sc-text-field-view, the sc- prefix indicates an override of the sc- CSS definitions in the Ace theme. Inspect your browser's elements listing, and you will see these references. In practice, you often need to dive into such an elements listing, and the fancy mouse-driven browser inspection tools, to diagnose CSS problems, such as the case of having bad math that results in one view obscuring another.

NOTE: CSS is an art unto itself, an important side of doing SproutCore development and building views.

Names of the files indicate their applicability: header.css, body.css, new_todo.css, and todo_item.css.

h6. header.css (resources directory)

<css filename="in apps/todos_three/resources/header.css">
$theme.toolbar {
  .checkbox {
    .button {
      left: 13px;
      top: 50%;
      margin-top: -8px;
    }

    .label {
      left: 47px;
      line-height: 36px;
    }
  }

  .sc-label-view {
    text-align: right;
    line-height: 36px;
    font-weight: bold;
    font-size: 18px;
    padding-right: 12px;
  }
}
</css>

h6. body.css (resources directory)

<css filename="in apps/todos_three/resources/body.css">
body {
  -webkit-font-smoothing: antialiased;
  text-rendering: optimizelegibility;
}

.sc-pane {
  -webkit-transform: none;
}
</css>

h6. new_todo.css (resources directory)

<css filename="in apps/todos_three/resources/new_todo.css">
$theme.new-todo {
  background-color: #FFF;
}

$theme.sc-text-field-view {
  background-color: transparent;
  font-size: 14px;

  .padding {
    left: 14px;
  }
}
</css>

h6. todo_item.css (resources directory)

<css filename="in apps/todos_three/resources/todo_item.css">
$theme.todo-item {
  .button {
    left: 13px;
    top: 50%;
    margin-top: -8px;
  }

  .label {
    left: 47px;
    line-height: 36px;
  }

  &.sel {
    background-color: white;
    color: #AAA;
    text-decoration: line-through;
  }
}
</css>

h5. loading.rhtml (resources directory)

SproutCore apps can weigh in north of the welterweight class, so while the app is loading we may need to show a loading indicator. For TodosThree we don't have to worry, but in larger apps, this file could need some attention.

<html filename="in apps/todos_three/resources/loading.rhtml">
<% content_for :loading do %>
<% # Any HTML in this file will be visible on screen while your page loads
   # its application JavaScript.  SproutCore applications are optimized for 
   # caching and startup very fast, so your users will often only see this 
   # content for a brief moment on their first app load, if at all.
%>
<p class="loading">Loading...<p>

<% end %>
</html>

h4. The Views Directory

*sproutcore gen* doesn't make a views directory, so we'll need to make one.

Before adding the views directory, some navigation is needed. We are still in the resources directory, so move back up to the TodosThree app root directory:

<shell>
$ pwd 
    ~/development/sproutcore/getting_started/apps/todos_three/resources/
$ cd ..
</shell>

Make a views directory:

<shell>
$ pwd 
    ~/development/sproutcore/getting_started/apps/todos_three/
$ mkdir views
$ cd views
</shell>

The views directory will contain two files: 

|_. todo_item.js |_. destroying_confirmation_pane.js |

h5. todo_item.js (views directory)

<javascript filename="in apps/todos_three/views/todo_item.js">
TodosThree.TodoItemView = SC.CheckboxView.design({
  classNames: ['todo-item'],
  valueBinding: '.content.isCompleted',
  titleBinding: SC.Binding.oneWay('.content.title')
});
</javascript>

TodoItemView is a checkbox, which has a label. You see a bit of wiring to CSS in the classNames property, an array of CSS class names that are to be applied to this view. valueBinding has a reference to .content.isCompleted. What is the context for this reference? We know that this view is defined as the exampleView property of the todos list. The term example here means "the view to use for each list item." List items for the todos list are todos, which are defined in the TodosThree.Todo model. So, .content used in the TodoItemView definition refers to a single todo item in the list. .content.isCompleted refers to this property of a todo item. Likewise, titleBinding is bound to the title property of a list todo item.

You have to think about where this view is used to understand it, but that comes with the territory of having individual views declared in separate files for convenience.

NOTE: It helps to name such views as SomethingItemView, because the Item part indicates the use in a list. 

h5. destroying_confirmation_pane.js (views directory)

<javascript filename="in apps/todos_three/views/destroying_confirmation_pane.js">
TodosThree.DestroyingConfirmationPane = SC.PanelPane.create({
  layout: { centerX: 0, top: 80, width: 380, bottom: 80 },
  theme: 'popover',
  defaultResponder: TodosThree.statechart,

  contentView: SC.WorkspaceView.design({
    layout: { left: 0, right: 0, top: 0, bottom: 0 },

    topToolbar: SC.ToolbarView.design({
      layout: { top: 0, left: 0, right: 0, height: 50 },
      childViews: "label".w(),

      label: SC.LabelView.design(SC.AutoResize, {
        layout: { centerX: 0, centerY: -5, height: 75 },
        value: "Clear Completed Todos",
        classNames: "embossed".w()
      })
    }),

    contentView: SC.ScrollView.design({
      layout: { left: 0, top: 20, right: 0, bottom: 0 },

      backgroundColor: 'red',

      contentView: SC.ListView.design({
        contentValueKey: 'title',

        todosBinding: 'TodosThree.todosController.content',
        todosDidChange: function() {
          var todos = this.get('todos');

          console.log('todosDidChange: ', todos);

          this.set('content', todos.filterProperty('isCompleted'));
        }.observes('todos', '*todos', '*todos.@each.isCompleted')
      })
    }),

    bottomToolbar: SC.ToolbarView.design({
      layout: { bottom: 0, height: 40 },

      childViews: 'confirmButton cancelButton'.w(),

      confirmButton: SC.ButtonView.design({
        layout: { right: 120, bottom: 10, width: 100, height: 24 },
        title: 'Confirm',
        action: 'clearCompletedTodos'
      }),

      cancelButton: SC.ButtonView.design({
        layout: { right: 10, bottom: 10, width: 100, height: 24 },
        title: 'Cancel',
        action: 'cancelDestroyingCompletedTodos',
        isDefault: YES
      })
    })
  })
});
</javascript>

The DestroyingConfirmationPane view presents the todos that are to be deleted, asking for confirmation. The completedTodos list presents a scrollable list of todos to be deleted. There are no actions associated with the list items. The confirm button has the action clearCompletedTodos, which lives in the DESTROYING_COMPLETED_TODOS state, the current state when this pane is showing on the screen. The cancel button has the action cancelDestroyingCompletedTodos, defined in the same state.

h4. The Models Directory

*sproutcore gen* does not make a models directory, so we'll make it.

Move up to the app root directory:

<shell>
$ pwd 
    ~/development/sproutcore/getting_started/apps/todos_three/resources/views/
$ cd ..
</shell>

Make a models directory:

<shell>
$ pwd 
    ~/development/sproutcore/getting_started/apps/todos_three/
$ mkdir models
$ cd models
</shell>

NOTE: SproutCore models are based on SC.Record, which offers a substantial set of data definition and processing functionality.

The models directory will contain one file:

|_. todo.js |

h5. todo.js (models directory)

<javascript filename="in apps/todos_three/models/todo.js">
sc_require('core');

TodosThree.Todo = SC.Record.extend({
  timestamp: SC.Record.attr(SC.DateTime),
  isCompleted: SC.Record.attr(Boolean),
  title: SC.Record.attr(String)
});
</javascript>

The Todo model has three properties: timestamp, isCompleted, and title. All are defined using the SC.Record.attr() helper (convenience) function, where builtin javascript types and Sproutcore types may be specified. There is much more that could be done in these property definitions, but for TodosThree, the basic types and their defaults will suffice.

NOTE: Recall discussion of good habits regarding sc_require. The use of sc_require('core'); here is not mandatory, but it is a good habit: TodosThree is defined in core.js.

h4. The Controllers Directory

*sproutcore gen* does not make a controllers directory, so we'll make it.

Move up to the TodosThree app root directory:

<shell>
$ pwd 
    ~/development/sproutcore/getting_started/apps/todos_three/models
$ cd ..
</shell>

Make a controllers directory:

<shell>
$ pwd 
    ~/development/sproutcore/getting_started/apps/todos_three/
$ mkdir controllers
$ cd controllers
</shell>

Controllers mediate communications. We'll need a couple in the TodosThree app.

The controllers directory will contain two files: 

|_. todos.js |_. completed_todos.js |

h5. todos.js (controllers directory)

<javascript filename="in apps/todos_three/controllers/todos.js">
sc_require('core');

TodosThree.todosController = SC.ArrayController.create({
});
</javascript>

h5. completed_todos.js (controllers directory)

<javascript filename="in apps/todos_three/controllers/completed_todos.js">
sc_require('controllers/todos');

TodosThree.completedTodosController = SC.ArrayController.create({

  totalTodosBinding: SC.Binding.oneWay('TodosThree.todosController.length'),

  areAllCompleted: function (k, v) {
    if (v !== undefined) {
      TodosThree.todosController.setEach('isCompleted', v);
    }
    return this.get('length') === this.get('totalTodos');
  }.property('length', 'totalTodos').cacheable()
});
</javascript>

The todosController has the simplest default definition as an SC.ArrayController. An array controller has a default _content_ reference to the data: you don't see a content property defined here, but take note, because you'll see prevalent use of the content property in most things controller.

The completedTodosController is another array controller. It has a property called totalTodosBinding, and a function called areAllCompleted(). 

totalTodosBinding is simple enough. It is a one-way binding (we are "pulling", we don't care about pushing back) to the length of the todosController array controller. We need a local reference to this length, because we are about to do something impressive, in part based on it.

areAllCompleted() is a function, but that very special type of function, the computed property. Note the .property() call hanging on the end of the function definition. This gives 'length' and 'totalTodos' as parameters, then tacks on .cacheable(). First, look at the parameters, which are references to local properties for this context, the array controller itself. We know we have a 'length' property -- this is a built-in property of an array controller. But what gives with the use of the 'totalTodos' reference -- isn't the property called totalTodosBinding? Ah, the answer is that anytime Binding is seen at the end of a property name, you have a kind of dual-property arrangement. The "actual" property is, in fact, totalTodos. In defining totalTodosBinding, we essentially say to get the value of totalTodos from this other source. 

That covers the background on mechanics of property names and bindings. Now to address what .property('length', 'totalTodos').cacheable() accomplishes:

  "Base this computed property on the length and totalTodos properties, and update it if either of them changes, and, also, cache the value so unnecessary updates are avoided." 

There is more to explain about the working of this computed property. What are the k and v parameters, and what does the internal code do? k and v are key and value. On a call, if v is a defined value, then the totalTodos value is being changed. This is a mandate to try to mark all todos as completed by this value. _The name of the computed property is *areAllCompleted*_. If a call is made to set it, then the body of the function needs to update the data accordingly. If v evaluates to true, then isCompleted for each todo item will be set and all the checkboxes will be checked in the list. That explains what the if block does. 

Notice the return on the last line in areAllCompleted(). We return the result of a test comparing the length of the array (the local 'length') to the length of the todos array (the local 'totalTodos', which is bound to an external source, the full todosController array). If these lengths are the same, then all todos have been marked as completed, otherwise no. 

INFO: A computed property used in this way is both a setter and a getter. Once you get the hang of making these you realize the benefit: automatic updating and caching for efficiency.

h4. The Fixtures Directory

*sproutcore gen* does not make a fixtures directory. We'll make it.

Move up to the TodosThree app root directory:

<shell>
$ pwd 
    ~/development/sproutcore/getting_started/apps/todos_three/controllers/
$ cd ..
</shell>

Make a fixtures directory:

<shell>
$ pwd 
    ~/development/sproutcore/getting_started/apps/todos_three/
$ mkdir fixtures
$ cd fixtures
</shell>

The fixtures directory will contain one file: 

|_. todo.js |

h5. todo.js (fixtures directory)

<javascript filename="in apps/todos_three/fixtures/todo.js">
sc_require('models/todo');

TodosThree.Todo.FIXTURES = [
 {
   guid: 0,
   isCompleted: YES,
   title: 'Add a SHOWING_APP state'
 },
 {
   guid: 1,
   isCompleted: YES,
   title: 'Edit the buildfile'
 },
 {
   guid: 2,
   isCompleted: YES,
   title: 'Add a TodosThree app'
 },
 {
   guid: 3,
   isCompleted: YES,
   title: 'Install SproutCore'
 }
];
</javascript>

h4. Running the App

With all that work done (or if you downloaded the code or cloned it from git) we can run the app, which we should do from the project root directory, where the project Buildfile lives:

<shell>
$ pwd 
    ~/development/sproutcore/getting_started/apps/todos_three/fixtures
$ cd ../../..
</shell>

And run it!

<shell>
$ pwd 
    ~/development/sproutcore/getting_started/
$ sproutcore server
</shell>

Visit http://localhost:4020/ in your favorite modern browser and you should see a list of apps, including TodosThree. 


* March 1, 2011: initial version by "Tom Dale":credits.html#tomdale and "Yehuda Katz":credits.html#wycats
* March 2, 2011: fixed formmating and added paths to filenames by "Topher Fangio":credits.html#topherfangio and "Peter Wagenet":credits.html#pwagenet
* March 22, 2011: cleaned up demo based on new features by "Yehuda Katz":credits.html#wycats
* April 11, 2011: consistently use view classes and extend, update to reflect better Handlebars integration by "Yehuda Katz":credits.html#wycats and "Tom Dale":credits.html#tomdale
* May 6, 2011: clarifications, minor inconsistency fixes, updated CSS for older browsers, plus new mobile section by "Tyler Keating":credits.html#publickeating
* May 9, 2011: update for recent changes in SproutCore 1.6 by "Tom Dale":credits.html#tomdale and "Yehuda Katz":credits.html#wycats
* February 29, 2012: rewrite for SproutCore 1.8 by the 1.8 release sprint team, including the following who did much work on this task: "Tim Evans":credits.html#tce, "Topher Fangio":credits.html#topherfangio, "Jeff Pittman":credits.html#geojeff

